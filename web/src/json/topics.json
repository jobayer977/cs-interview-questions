{"1. What is Big O notation?":[{"title":"What is Big O notation?","content":"\nBig O Notation is a way to measure an algorithm's efficiency. It measures the time it takes to run your function as the input grows.\n","section":"1. What is Big O notation?","source":"https://towardsdatascience.com/"}],"2. What is meant by linear search?":[{"title":"What is meant by linear search?","content":"\nA linear search is a simple search algorithm that looks at each element in the data set and checks if the element is the one you are looking for. Starting at the beginning of the data set. Once the item is found, the search ends.\n\n```javascript\nfunction linearSearch(arr, item) {\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tif (arr[i] === item) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nlinearSearch([1, 2, 3, 4, 5], 3) // true\n```\n\n**Big O Notation**\nThe time complexity is O(n) because the algorithm has to look at each element in the data set.\n","section":"2. What is meant by linear search?","source":"https://www.bbc.co.uk/bitesize/guides/z7kkw6f/revision/7"}],"3. What is o(n) time complexity":[{"title":"what is o(n) time complexity","content":"\nLinear time complexity O(n) means that the algorithms take proportionally longer to complete as the input grows.\n\nExamples of linear time algorithms: Get the max/min value in an array.\n\n```js\nfunction getMax(arr) {\n\tlet max = arr[0]\n\tfor (let i = 1; i < arr.length; i++) {\n\t\tif (arr[i] > max) {\n\t\t\tmax = arr[i]\n\t\t}\n\t}\n\treturn max\n}\n\nfunction getMin(arr) {\n\tlet min = arr[0]\n\tfor (let i = 1; i < arr.length; i++) {\n\t\tif (arr[i] < min) {\n\t\t\tmin = arr[i]\n\t\t}\n\t}\n\treturn min\n}\n\nconst arr = [1, 2, 3, 4, 5]\n\nconst max = getMax(arr)\nconst min = getMin(arr)\n```\n\nIn the above example, the algorithm is O(n) because it has to loop through the array once to find the max and once to find the min value. The loop is dependent on the size of the array.\n","section":"3. What is o(n) time complexity"}],"4. What is binary searching?":[{"title":"What is binary searching?","content":"\nBinary search is a search algorithm that works by comparing the target value to the middle element of the data set. If the target value is less than the middle element, the algorithm repeats the process on the lower half of the data set. If the target value is greater than the middle element, the algorithm repeats the process on the upper half of the data set.\n\n```javascript\nfunction binarySearch(arr, item) {\n\tlet low = 0\n\tlet high = arr.length - 1\n\n\twhile (low <= high) {\n\t\tconst mid = Math.floor((low + high) / 2)\n\t\tconst guess = arr[mid]\n\n\t\tif (guess === item) {\n\t\t\treturn true\n\t\t}\n\n\t\tif (guess > item) {\n\t\t\thigh = mid - 1\n\t\t} else {\n\t\t\tlow = mid + 1\n\t\t}\n\t}\n\n\treturn false\n}\n\nbinarySearch([1, 2, 3, 4, 5], 3) // true\n```\n\n**Note:** The above algorithm is `O(log n)` because it has to divide the data set in half every time it loops.\n","section":"4. What is binary searching?"}],"5. When should you not use binary search?":[{"title":"When should you not use binary search?","content":"\nIn case the list of elements is not sorted, there's no way to use binary search because the median value of the list can be anywhere and when the list is split into two parts, the element that you were searching for could be cut off. This is why binary search is not useful.\n","section":"5. When should you not use binary search?","source":"https://blog.logrocket.com/why-binary-search-is-useful/"}]}